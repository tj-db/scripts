<!DOCTYPE html> <html lang="en"> <head>     <meta charset="UTF-8">     <meta name="viewport" content="width=device-width, initial-scale=1.0">     <title>MEET</title>     <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>     <style>         body, html {             margin: 0;             padding: 0;             height: 100%;             overflow: hidden;             font-family: Arial, sans-serif;         }         #canvas {             position: absolute;             top: 0;             left: 0;             width: 100%;             height: 100%;             background-color: black;         }         #controls {             position: absolute;             top: 10px;             left: 10px;             z-index: 10;             user-select: none;             -webkit-tap-highlight-color: transparent;         }         button, input {             background-color: rgba(255, 255, 255, 0);             border: none;             color: white;             padding: 5px 11px;             margin: 2px;             cursor: pointer;             user-select: none;             -webkit-tap-highlight-color: transparent;         }         #chat-area {             position: absolute;             bottom: 0;             left: 0;             width: 100%;             background-color: rgba(0, 0, 0, 0.5);             color: white;             padding: 10px;             box-sizing: border-box;             opacity: 0.4;             transition: opacity 0.3s ease;         }         #chat-area:hover {             opacity: 1;         }         #chat-messages {             height: 72px;             overflow-y: auto;         }         #chat-messages::-webkit-scrollbar {             width: 0;             background: transparent;         }         #chat-messages {             scrollbar-width: none;             -ms-overflow-style: none;         }         #message-input {             width: calc(100% - 140px);             background-color: rgba(255, 255, 255, 0.2);             user-select: none;             border-radius: 11px;             padding-left: 10px;             margin-top:11px;         }         #voip-btn {             color: rgba(255, 255, 255, 0.3);             user-select: none;         }         #voip-btn.active {             color: rgba(255, 255, 255, 1);             user-select: none;         }         #color-picker {             -webkit-appearance: none;             appearance: none;             border: none;             border-radius: 50%;             width: 33px;             height: 33px;             padding: 0;             cursor: pointer;             overflow: hidden;             -webkit-tap-highlight-color: transparent;         }         #color-picker::-webkit-color-swatch-wrapper {             padding: 0;             -webkit-tap-highlight-color: transparent;         }         #color-picker::-webkit-color-swatch {             border: none;             border-radius: 50%;             -webkit-tap-highlight-color: transparent;         }         #brush-size {             width: 60px;         }      </style> </head> <body>     <canvas id="canvas"></canvas>     <div id="controls">         <input type="color" id="color-picker" value="#ffffff">         <input type="range" id="brush-size" min="1" max="66" value="2">         <button id="clear-btn">clear</button>         <button id="undo-btn">undo</button>         <button id="voip-btn">&#128266;</button>         <button id="copy-peer-id-btn">&#x1F517;</button>     </div>     <div id="chat-area">         <div id="chat-messages"></div>         <input type="text" id="message-input" placeholder="Type a message...">         <button id="send-btn">Send</button>     </div>      <script>         const canvas = document.getElementById('canvas');         const ctx = canvas.getContext('2d');         const colorPicker = document.getElementById('color-picker');         const brushSize = document.getElementById('brush-size');         const clearBtn = document.getElementById('clear-btn');         const undoBtn = document.getElementById('undo-btn');         const chatMessages = document.getElementById('chat-messages');         const messageInput = document.getElementById('message-input');         const sendBtn = document.getElementById('send-btn');         const voipBtn = document.getElementById('voip-btn');          let isDrawing = false;         let path = [];         let drawHistory = [];         let localStream;         let isVoipActive = false;          function resizeCanvas() {             canvas.width = window.innerWidth;             canvas.height = window.innerHeight;             redrawCanvas();         }         resizeCanvas();         window.addEventListener('resize', resizeCanvas);          document.addEventListener('mousedown', (e) => {             if (e.target === canvas) {                 startDrawing(e);             }         });          document.addEventListener('mousemove', (e) => {             if (isDrawing && e.target === canvas) {                 draw(e);             }         });          document.addEventListener('mouseup', stopDrawing);         document.addEventListener('touchstart', (e) => {             if (e.target === canvas) {                 e.preventDefault();                 startDrawing(e.touches[0]);             }         });          document.addEventListener('touchmove', (e) => {             if (isDrawing && e.target === canvas) {                 e.preventDefault();                 draw(e.touches[0]);             }         });          document.addEventListener('touchend', stopDrawing);          function startDrawing(e) {             isDrawing = true;             path = [{ x: e.clientX - canvas.offsetLeft, y: e.clientY - canvas.offsetTop }];         }          function draw(e) {             if (!isDrawing) return;              const newPoint = { x: e.clientX - canvas.offsetLeft, y: e.clientY - canvas.offsetTop };             path.push(newPoint);              if (path.length > 2) {                 const prevPoint = path[path.length - 2];                 const midPoint = getMidPoint(prevPoint, newPoint);                  ctx.beginPath();                 ctx.moveTo(prevPoint.x, prevPoint.y);                 ctx.quadraticCurveTo(midPoint.x, midPoint.y, newPoint.x, newPoint.y);                 ctx.strokeStyle = colorPicker.value;                 ctx.lineWidth = brushSize.value;                 ctx.lineCap = 'round';                 ctx.stroke();             }         }          function stopDrawing() {             if (!isDrawing) return;             isDrawing = false;              if (path.length > 2) {                 drawHistory.push({                     type: 'drawPath',                     path: path,                     color: colorPicker.value,                     lineWidth: brushSize.value                 });                 broadcast({ type: 'drawPath', path: path, color: colorPicker.value, lineWidth: brushSize.value });                 redrawCanvas();             }         }          function getMidPoint(p1, p2) {             return {                 x: (p1.x + p2.x) / 2,                 y: (p1.y + p2.y) / 2             };         }          clearBtn.addEventListener('click', () => {             ctx.clearRect(0, 0, canvas.width, canvas.height);             drawHistory = [];             broadcast({ type: 'clear' });         });          undoBtn.addEventListener('click', () => {             if (drawHistory.length > 0) {                 drawHistory.pop();                 redrawCanvas();                 broadcast({ type: 'undo' });             }         });          function redrawCanvas() {             ctx.clearRect(0, 0, canvas.width, canvas.height);             drawHistory.forEach(item => {                 if (item.type === 'drawPath') {                     drawPath(item.path, item.color, item.lineWidth);                 }             });         }          const peer = new Peer();         let connections = [];          peer.on('open', (id) => {             console.log('Your peer ID is: ' + id);             hashHandler();         });          peer.on('connection', (conn) => {             connections.push(conn);             setupConnection(conn);         });          peer.on('call', (call) => {             if (isVoipActive && localStream) {                 call.answer(localStream);                 setupVoipCall(call);             }         });          function setupConnection(conn) {             conn.on('data', (data) => {                 if (data.type === 'drawPath') {                     drawPath(data.path, data.color, data.lineWidth);                     drawHistory.push(data);                 } else if (data.type === 'clear') {                     ctx.clearRect(0, 0, canvas.width, canvas.height);                     drawHistory = [];                 } else if (data.type === 'undo') {                     if (drawHistory.length > 0) {                         drawHistory.pop();                         redrawCanvas();                     }                 } else if (data.type === 'chat') {                     addChatMessage(conn.peer, data.message);                 }             });              conn.on('close', () => {                 connections = connections.filter(c => c !== conn);             });         }          function broadcast(data) {             connections.forEach(conn => conn.send(data));         }          function drawPath(path, color, lineWidth) {             if (path.length < 2) return;              ctx.beginPath();             ctx.moveTo(path[0].x, path[0].y);             for (let i = 1; i < path.length; i++) {                 const midPoint = getMidPoint(path[i - 1], path[i]);                 ctx.quadraticCurveTo(path[i - 1].x, path[i - 1].y, midPoint.x, midPoint.y);             }             ctx.strokeStyle = color;             ctx.lineWidth = lineWidth;             ctx.lineCap = 'round';             ctx.stroke();         }          function addChatMessage(sender, message) {             const messageElement = document.createElement('div');             messageElement.textContent = `${sender}: ${message}`;             chatMessages.appendChild(messageElement);             chatMessages.scrollTop = chatMessages.scrollHeight;         }          sendBtn.addEventListener('click', sendMessage);         messageInput.addEventListener('keypress', (e) => {             if (e.key === 'Enter') sendMessage();         });          function sendMessage() {             const message = messageInput.value.trim();             if (message) {                 addChatMessage('You', message);                 broadcast({ type: 'chat', message: message });                 messageInput.value = '';             }         }          function hashHandler() {             const hash = window.location.hash.substring(1);             if (hash) {                 connectToPeer(hash);             }         }          function connectToPeer(peerId) {             const conn = peer.connect(peerId);             connections.push(conn);             setupConnection(conn);         }          window.addEventListener('load', () => {             hashHandler();         });          window.addEventListener('hashchange', hashHandler);          voipBtn.addEventListener('click', toggleVoip);          function toggleVoip() {             if (isVoipActive) {                 stopVoip();             } else {                 startVoip();             }         }          function startVoip() {             navigator.mediaDevices.getUserMedia({ audio: true, video: false })                 .then((stream) => {                     localStream = stream;                     isVoipActive = true;                     voipBtn.classList.add('active');                     connections.forEach(conn => {                         const call = peer.call(conn.peer, stream);                         setupVoipCall(call);                     });                 })                 .catch((err) => console.error('Failed to get local stream', err));         }          function stopVoip() {             if (localStream) {                 localStream.getTracks().forEach(track => track.stop());                 localStream = null;             }             isVoipActive = false;             voipBtn.classList.remove('active');         }          function setupVoipCall(call) {             call.on('stream', (remoteStream) => {                 const audio = new Audio();                 audio.srcObject = remoteStream;                 audio.play();             });         }          const copyPeerIdBtn = document.getElementById('copy-peer-id-btn');          function copyPeerIdToClipboard() {             const peerId = peer.id;             const urlToCopy = `https://framellarchive.github.io/MEET/#${peerId}`;              navigator.clipboard.writeText(urlToCopy).then(() => {                 console.log('Peer ID copied to clipboard:', urlToCopy);                 addChatMessage('System', 'LINK copied to clipboard.');             }).catch(err => {                 console.error('Failed to copy: ', err);             });         }          copyPeerIdBtn.addEventListener('click', copyPeerIdToClipboard);      </script> </body> </html>